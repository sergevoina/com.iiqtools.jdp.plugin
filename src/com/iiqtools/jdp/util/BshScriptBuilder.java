package com.iiqtools.jdp.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.text.StrSubstitutor;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.runtime.Assert;
import org.eclipse.jdt.core.IAnnotation;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IField;
import org.eclipse.jdt.core.IImportDeclaration;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IOpenable;
import org.eclipse.jdt.core.ISourceRange;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.SourceRange;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.SimpleName;

import com.iiqtools.jdp.Messages;

public class BshScriptBuilder {

	private final ICompilationUnit compilationUnit;
	private final String cuSource;
	private final IType topLevelType;
	private final ArtefactInfo artefactInfo;
	private final IFile targetFile;

	private final BshScriptValidator validator;
	private final List<String> syntaxErrors = new ArrayList<>();

	private final String lineSeparator;
	private final List<String> importsToIgnore;

	private String script = null;

	private BshScriptBuilder(ICompilationUnit compilationUnit, String cuSource, IType topLevelType,
			ArtefactInfo artefactInfo, IFile targetFile) {
		this.compilationUnit = compilationUnit;
		this.cuSource = cuSource;
		this.topLevelType = topLevelType;
		this.artefactInfo = artefactInfo;
		this.targetFile = targetFile;

		this.validator = new BshScriptValidator(compilationUnit.getJavaProject());

		this.lineSeparator = "\n";

		List<String> list = new ArrayList<String>();
		list.add("com.iiqtools.jdp.annotation");
		// default imports in BeanShell
		// http://beanshell.org/manual/bshmanual.html#Importing_Classes_and_Packages
		list.add("javax.swing.event");
		list.add("javax.swing");
		list.add("java.awt.event");
		list.add("java.awt");
		list.add("java.net");
		list.add("java.util");
		list.add("java.io");
		list.add("java.lang");

		this.importsToIgnore = Collections.unmodifiableList(list);
	}

	public ICompilationUnit getCompilationUnit() {
		return compilationUnit;
	}

	public IType getTopLevelType() {
		return topLevelType;
	}

	public ArtefactInfo getArtefactInfo() {
		return artefactInfo;
	}

	public IFile getTargetFile() {
		return targetFile;
	}

	public boolean isValid() {
		return this.syntaxErrors.isEmpty();
	}

	public String getScript() {
		return script;
	}

	public String getErrorMessage() {
		StringBuilder sb = new StringBuilder();

		sb.append(Messages.basicStructuralValidation).append(System.lineSeparator()).append(System.lineSeparator());

		for (String err : this.syntaxErrors) {
			sb.append(err).append(System.lineSeparator());
		}

		return sb.toString();
	}

	protected void internalParse() throws Exception {

		final StringBuilder sb = new StringBuilder();
		sb.append(this.lineSeparator);

		appendHeader(sb);
		appendImportDeclarations(sb);
		appendFields(sb);
		appendMethods(sb);

		this.script = sb.toString();
	}

	protected void appendHeader(final StringBuilder sb) {
		// Generated by <Author> on <Date> from
		// <Class name>
		if (this.artefactInfo.header && (this.artefactInfo.headerText != null)) {
			Map<String, String> valueMap = new HashMap<String, String>();
			valueMap.put("eol", this.lineSeparator);
			valueMap.put("date", String.valueOf(new Date()));
			valueMap.put("className", topLevelType.getFullyQualifiedName());
			valueMap.putAll(System.getenv());

			StrSubstitutor substitutor = new StrSubstitutor(valueMap);

			String header = substitutor.replace(this.artefactInfo.headerText);

			header = header.replace("/*", "/@").replace("*/", "@/");

			sb.append("/* ").append(header).append(" */").append(this.lineSeparator);

		}
	}

	protected void appendImportDeclarations(StringBuilder sb) throws JavaModelException {

		List<String> listOfImports = new ArrayList<String>();
		IImportDeclaration[] imports = this.compilationUnit.getImports();
		if (imports != null) {
			for (IImportDeclaration importDeclaration : imports) {
				String s = importDeclaration.getElementName();
				if (s != null) {
					s = s.trim();
				}
				if (PluginUtil.isNotNullOrEmpty(s)) {
					listOfImports.add(importDeclaration.getElementName());
				}
			}
		}

		appendImportDeclarations(sb, listOfImports, true, true, true);
	}

	protected void appendImportDeclarations(StringBuilder sb, List<String> listOfImports, boolean sort, boolean excl,
			boolean split) {
		Assert.isNotNull(sb);
		Assert.isNotNull(listOfImports);

		if (sort) {
			Collections.sort(listOfImports);
		}

		boolean appendEol = false;
		String prev = null;
		for (String s : listOfImports) {
			if (!excl || !ignore(s)) {
				if (needSplit(prev, s)) {
					sb.append(this.lineSeparator);
				}

				sb.append("import ").append(s).append(";").append(this.lineSeparator);
				prev = s;
				appendEol = true;
			}
		}

		if (appendEol) {
			sb.append(this.lineSeparator);
		}
	}

	protected void appendFields(final StringBuilder sb) throws JavaModelException {

		boolean appendEol = false;
		IField[] fields = this.topLevelType.getFields();
		for (IField field : fields) {
			IAnnotation annotation = field.getAnnotation("ArtefactIgnore");
			if (!annotation.exists()) {

				// get source range associated with this element
				ISourceRange sourceRange = roundUpOffset(field.getSourceRange());
				validateAndAppendBlock(sb, sourceRange, 1);

				sb.append(this.lineSeparator);
				appendEol = true;
			}
		}

		if (appendEol) {
			sb.append(this.lineSeparator);
		}
	}

	protected void appendMethods(final StringBuilder sb) throws Exception {

		IMethod bodyMethod = null;

		IMethod[] methods = this.topLevelType.getMethods();
		for (IMethod method : methods) {
			if (JdtUtil.hasAnnotation(method, "ArtefactBody")) {
				bodyMethod = method;
			} else if (JdtUtil.hasAnnotation(method, "ArtefactScript")) {

				// currently it ignores the source method completely and uses
				// the annotation's value.
				// However the annotation's value is validated for BeanShell
				// syntax
				ArtefactScriptInfo artefactScript = ArtefactScriptInfo.parse(method);
				if (artefactScript == null) {
					throw new Exception(
							"Failed to parse ArtefactScript annotation on method " + method.getElementName());
				}

				ISourceRange sourceRange = artefactScript.annotation.getSourceRange();
				validateSyntax(artefactScript.value, sourceRange.getOffset());

				sb.append(lineSeparator).append(artefactScript.value).append(lineSeparator);

				// TODO: the better solution would be to replace the method's
				// body
				// with the annotation's value and remove ArtefactScript
				// annotation

			} else if (!JdtUtil.hasAnnotation(method, "ArtefactIgnore")) {
				ISourceRange sourceRange = roundUpOffset(method.getSourceRange());

				validateAndAppendBlock(sb, sourceRange, 1);

				sb.append(this.lineSeparator).append(this.lineSeparator);
			}
		}

		// we want only inner body, without method declaration
		if (bodyMethod != null) {
			final String methodName = bodyMethod.getElementName();

			ASTParser parser = ASTParser.newParser(AST.JLS_Latest);
			parser.setKind(ASTParser.K_COMPILATION_UNIT);
			parser.setSource(compilationUnit);
			parser.setResolveBindings(true);
			CompilationUnit cu = (CompilationUnit) parser.createAST(null);

			if (cu == null) {
				throw new Exception("Failed to get a compilation unit AST for the given Java element.");
			}

			cu.accept(new ASTVisitor() {
				@Override
				public boolean visit(MethodDeclaration node) {

					SimpleName simpleName = node.getName();
					if (simpleName.toString().equals(methodName)) {
						Block block = node.getBody();

						int s = block.getStartPosition();
						int l = block.getLength();

						ISourceRange sourceRange = new SourceRange(s + 1, l - 2);
						validateAndAppendBlock(sb, sourceRange, 2);

						sb.append(lineSeparator);
					}
					return false;
				};
			});
		}
	}

	protected boolean needSplit(String prev, String next) {
		if (prev != null && next != null) {
			int prevInd = prev.indexOf('.');
			if (prevInd != -1) {
				prev = prev.substring(0, prevInd);
			}
			int nextInd = next.indexOf('.');
			if (nextInd != -1) {
				next = next.substring(0, nextInd);
			}
			return !prev.equals(next);
		}
		return false;
	}

	protected boolean ignore(String imp) {
		if (imp != null) {
			for (String s : this.importsToIgnore) {
				if (imp.startsWith(s)) {
					String suffix = imp.substring(s.length());
					// first char must be '.'
					if ((suffix.length() > 1) && (suffix.charAt(0) == '.')) {
						// no more dots
						return (suffix.indexOf('.', 1) == -1);
					}
				}
			}
		}
		return false;
	}

	protected ISourceRange roundUpOffset(ISourceRange sourceRange) {

		int offset = sourceRange.getOffset();
		int length = sourceRange.getLength();

		// go up until new line
		while (offset > 0) {
			char ch = cuSource.charAt(offset);
			if (ch == '\r' || ch == '\n') {
				break;
			}

			// if (!Character.isWhitespace(ch) || ch == '\r' || ch == '\n') {
			// offset++;
			// length--;
			// break;
			// }
			offset--;
			length++;
		}

		return new SourceRange(offset, length);
	}

	protected void validateAndAppendBlock(StringBuilder sb, ISourceRange sourceRange, int shiftLeft) {
		int offset = sourceRange.getOffset();
		int length = sourceRange.getLength();

		String script = cuSource.substring(offset, offset + length);

		validateSyntax(script, offset);

		for (int i = 0; i < shiftLeft; ++i) {
			script = PluginUtil.shiftLeft(script);
		}
		sb.append(script);
	}

	protected void validateSyntax(String script, int offset) {
		StringBuilder sb = new StringBuilder();
		int cn = Math.min(this.cuSource.length(), offset);
		for (int i = 0; i < cn; i++) {
			if (this.cuSource.charAt(i) == '\n') {
				sb.append('\n');
			}
		}
		sb.append(script);

		BshSyntaxError error = validator.validate(sb.toString());
		if (error != null) {
			this.syntaxErrors.add(error.getMessage());
		}
	}

	public static BshScriptBuilder parse(ICompilationUnit compilationUnit) throws Exception {

		if (compilationUnit instanceof IOpenable) {
			IOpenable openable = (IOpenable) compilationUnit;
			if (openable.hasUnsavedChanges()) {
				throw new Exception(Messages.hasUnsavedChangesError);
			}
		}

		IMarker[] markers = JdtUtil.getJavaProblemMarkers(compilationUnit);
		if (markers.length > 0) {
			boolean hasErrors = false;
			// boolean hasWarining = false;
			StringBuilder sb = new StringBuilder();
			sb.append("Please fix all errors first:");

			for (IMarker marker : markers) {
				Map<String, Object> map = marker.getAttributes();

				int severity = (int) map.get("severity");

				if (severity == IMarker.SEVERITY_ERROR) {
					hasErrors = true;
					sb.append(System.lineSeparator()).append(map.get("message"));
				}
				// if (severity == IMarker.SEVERITY_WARNING) {
				// hasWarining = true;
				// }
			}

			if (hasErrors) {
				throw new Exception(Messages.hasJavaProblemsError);
			}

			// if (hasWarining) {
			// MessageDialog.openInformation(window.getShell(), "Custom
			// Container",
			// "The compilation unit has warnings!");
			// }
		}

		IType topLevelType = JdtUtil.resolveTopLevelType(compilationUnit);
		if (topLevelType == null) {
			throw new Exception(Messages.cannotFindTopLevelTypeError);
		}

		ArtefactInfo artefactInfo = ArtefactInfo.parse(topLevelType);
		if (artefactInfo == null) {
			throw new Exception(Messages.cannotFindArtefactAnnotationError);
		}

		// check if we have a Java project
		// if (project.isNatureEnabled("org.eclipse.jdt.core.javanature")) {
		// IJavaProject javaProject = JavaCore.create(project);
		// printPackageInfos(javaProject);
		// }

		IFile targetFile = topLevelType.getJavaProject().getProject().getFile(artefactInfo.target);
		if (targetFile == null) {
			throw new Exception(Messages.cannotFindArtefactAnnotationError);
		}

		BshScriptBuilder bshScript = new BshScriptBuilder(compilationUnit, compilationUnit.getSource(), topLevelType,
				artefactInfo, targetFile);
		bshScript.internalParse();
		return bshScript;
	}
}
